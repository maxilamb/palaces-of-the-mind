# Защита node.js приложения

### 1. Используйте правила для линтера, в том числе направленные на проверку безопасности кода

Линтер не должен быть всего лишь инструментом, следящим за применением правил.
`eslint-plugin-security` позволяет обнаруживать в коде широкий спектр потенциально опасных шаблонов и устранять их.

[Подробнее](https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/lintrules.md)

### 2. Ограничивайте количество одновременных запросов к серверу

DoS-атаки весьма популярны среди злоумышленников, проводить их сравнительно просто.
Реализовать систему ограничения количества запросов к приложению можно с использованием внешнего сервиса,
такого, как облачный балансировщик нагрузки, облачный файрвол, nginx-сервер, или, для небольших приложений,
не являющихся критически важными, с использованием промежуточного ПО для ограничения числа запросов вроде `express-rate-limit`.

### 3. Предотвращайте внедрение кода

Для того чтобы предотвратить SQL/NoSQL-инъекции и другие подобные атаки, всегда применяйте ORM/ODM-библиотеки или механизмы СУБД,
направленные на очистку данных. Никогда не пользуйтесь, для внедрения неких значений в тексты запросов, лишь шаблонными строками JavaScript, 
или конкатенацией строк, так как такой подход открывает ваше приложение для широкого спектра уязвимостей. 

[Подробнее](https://github.com/goldbergyoni/nodebestpractices/blob/security-best-practices-section/sections/security/ormodmusage.md)

### 4. Управляемое падение приложения

Процесс Node аварийно завершает работу при возникновении необработанной ошибки.
Но во многих рекомендациях, отражающих передовой опыт разработки для Node, рекомендуется завершать процессы даже тогда,
когда возникшая ошибка была перехвачена и обработана. Express, например, аварийно завершится при возникновении 
любой асинхронной ошибки — если только маршруты не будут обёрнуты в выражения catch. Этот факт открывает атакующим весьма привлекательную возможность.
Они, обнаружив, что при поступлении определённого запроса процесс аварийно завершается, начинают отправлять ему именно такие запросы.
Нет рекомендации, которая позволила бы одним махом решить эту проблему, однако, некоторые приёмы могут её смягчить. 
Так, при завершении процесса из-за необработанной ошибки, нужно уведомлять администратора, давая такому уведомлению высший приоритет важности. 
Надо проверять то, что приходит процессу в запросах и избегать ситуаций аварийного завершения процесса из-за запросов, которые, 
случайно или намеренно, сформированы неправильно. Все маршруты нужно оборачивать в выражения catch и настроить систему так, чтобы, 
если причиной ошибки является запрос, процесс не завершался бы аварийно (в противоположность тому, что происходит на глобальном уровне приложения).

### 5. Настройте заголовки HTTP-ответов для повышения уровня безопасности проекта

Приложение должно использовать HTTP-заголовки, ориентированные на безопасность, для того, чтобы не дать злоумышленникам
прибегнуть к таким распространённым приёмам совершения атак, как межсайтовый скриптинг (XSS), кликджекинг, и другие.
Настроить заголовки несложно с использованием специальных модулей, таких, как `helmet`.

[Подробнее](https://github.com/goldbergyoni/nodebestpractices/blob/security-best-practices-section/sections/security/secureheaders.md)

### 6. Постоянно, в автоматическом режиме, проверяйте свои проекты на использование в них уязвимых зависимостей

В экосистеме NPM проекты, имеющие множество зависимостей — это весьма распространённое явление.
Зависимости всегда нужно контролировать, учитывая обнаружение новых уязвимостей. 
Используйте для обнаружения, мониторинга и исправления уязвимых зависимостей инструменты вроде `npm audit`, `nsp` или `snyk`. 
Встройте эти инструменты в свою систему непрерывной интеграции. Это позволит вам обнаруживать уязвимые зависимости до того, как они попадут в продакшн.

### 7. Используйте системы экранирования символов в HTML, JS и CSS-данных, отправляемых пользователю

Если в браузер пользователя отправляются некие данные из недоверенного источника,
то, даже если они должны быть просто выведены на экран, такие данные могут представлять собой код, который может быть выполнен. 
Обычно подобное называют межсайтовым скриптингом (XSS). 
Снизить риск возможности проведения подобных атак можно, 
используя специальные библиотеки, которые обрабатывают данные так, что они не могут быть выполнены. 
Это называют кодированием или экранированием данных.

### 8. Проверяйте JSON-данные, поступающие на сервер

Контролируйте содержимое тел входящих запросов, проверяя, соответствуют ли они тому, что вы ждёте увидеть в подобных запросах.
Если запрос выглядит не так, как ожидается, быстро прекращайте его обработку.
Для того чтобы избежать трудоёмкой операции написания кода проверки запросов для каждого маршрута, вы можете воспользоваться легковесными 
JSON-средствами для валидации данных, такими, как `express-validator`, ``, `jsonschema` или `joi`.

### 9. Поддерживайте чёрные списки JWT-токенов

При использовании JWT-токенов (например, если вы работаете с Passport.js), 
по умолчанию, нет стандартного механизма для отзыва привилегий на доступ к системе для уже выпущенных токенов.
Если даже вы обнаружили, что некий пользователь делает что-то явно ненормальное, у вас нет способа, 
через механизм токенов, закрыть ему доступ в систему, до тех пор, пока у него имеется действительный токен. 
Смягчить эту проблему можно, реализовав чёрный список недоверенных токенов, валидация которых производится при каждом запросе.


### 10. Ограничьте количество попыток входа в систему

В приложениях, основанных на express, для защиты от атак методом грубой силы и от атак по словарю, 
стоит использовать соответствующее промежуточное ПО, такое, как `express-brute`.
Подобным образом нужно защищать особо важные маршруты, такие, как /admin или /login. 
Защита должна быть основана на анализе свойств запросов, таких, как использованное 
в запросе имя пользователя или другие идентификаторы, такие, как параметры тела запроса.

### 11. Запускайте Node.js от имени пользователя, не обладающего root-привилегиями

Чрезвычайно распространён сценарий, при использовании которого Node.js запускается от имени root-пользователя с неограниченными привилегиями.
Например, именно так всё по умолчанию настроено в контейнерах Docker.
Рекомендуется создавать пользователя, не обладающего root-правами, и либо встраивать его в образ Docker,
либо запускать процесс от имени этого пользователя, вызывая контейнер с флагом `-u username`.

[Подробнее](https://github.com/goldbergyoni/nodebestpractices/blob/security-best-practices-section/sections/security/non-root-user.md)

### 12. Ограничьте объёмы данных, передаваемых в запросах, с использованием обратного прокси-сервера или промежуточного ПО

Чем больше объём данных, находящихся в теле запроса, тем сложнее однопоточному серверу такой запрос обработать. 
Использование запросов больших размеров даёт атакующему возможность завалить сервер ненужной работой
и без отправки ему огромного числа запросов (то есть, не выполняя DoS/DDoS-атаку). 
Снизить риск подобных атак можно, ограничивая размер тел входящих запросов
на некой пограничной системе (на файрволе или на балансировщике нагрузки), 
или настроив `body-parser` на приём только пакетов, содержащих небольшой объём данных.

### 13. Не допускайте перегрузки однопоточных Node.js-приложений вредоносными регулярными выражениями

Регулярные выражения, хотя они и удобны, несут в себе угрозу для JavaScript-приложений в целом, и, в частности, для платформы Node.js.
Обработка с помощью регулярного выражения того, что пришло от пользователя, может создать огромную нагрузку на процессор. 
Например, обработка регулярных выражений может быть настолько неэффективной,
что проверка десяти слов может заблокировать цикл событий на несколько секунд и сверх меры нагрузить процессор. 
Поэтому лучше всего пользоваться сторонними пакетами для проверки строковых данных, вроде `validator.js`,
вместо написания собственных регулярных выражений. 
Можно воспользоваться пакетом `safe-regex` для обнаружения уязвимых шаблонов регулярных выражений.

### 14. Выполняйте небезопасный код в песочнице

При возникновении необходимости выполнения внешнего кода, попадающего в приложение во время его работы,
используйте «песочницу», которая изолирует и защищает основной код от кода плагина.
Подобную среду можно создать, используя выделенный процесс `cluster.fork()`,
бессерверное окружение или выделенный npm-пакет, действующий как песочница.

[Подробнее](https://github.com/goldbergyoni/nodebestpractices/blob/security-best-practices-section/sections/security/sandbox.md)

### 15. Будьте особенно осторожны при работе с дочерними процессами

Избегайте, когда это возможно, использования дочерних процессов. 
Если же без этого не обойтись, то проверяйте и очищайте данные,
переданные пользователем и используемые при запуске таких процессов для того, чтобы снизить риск атаки на командную оболочку.
При этом отдавайте предпочтение команде `child_process.execFile`, которая, по умолчанию, не запускает командную оболочку,
создавая новый процесс который соответствует запущенному исполняемому файлу, переданному ей.

[Подробнее](https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/childprocesses.md)


### 16. Скрывайте техническую информацию ошибки от пользователя

Используйте error handler для вашего backend приложения. 
Сообщения об ошибке присылаемые клиенту должны быть структурированы и содержать миниум в соответствии с вашим архитектурным стилем
